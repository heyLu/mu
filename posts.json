[
	{
		"id": "06febb5bfa6edd7db92a498f2585820e",
		"title": "Next steps",
		"content": "There's a `file` backend since yesterday, it stores the latest db using fressian in a single file.  Yes, that means there's no history when loading from disk, but it's a start.\r\n\r\nSo, what now?  I want to use it, but there are quite a few things missing.\r\n\r\nHere's what I want next:\r\n\r\n- do \"raw index\" queries (`datoms` and/or `seek-datoms`)\r\n- get an entity by id (or ident) from a db (`entity`)\r\n- some kind of transactions\r\n    - need to generate new ids for that (and keep track of them on disk)\r\n    - not sure about \"verification\" (e.g. checking cardinality, types, ...)\r\n    - updates are tricky\r\n- lightweight queries (although raw index queries are probably enough for the start?)\r\n    - need an EDN parser\r\n\r\nAnd then:\r\n\r\n- a `server` cmd, similar to datomic's rest api",
		"created": "2015-05-23T12:19:11.267497199+02:00"
	},
	{
		"id": "eb4136774a202c7a084f0735f731a811",
		"title": "An initial in-memory backend",
		"content": "Aka: **success**, we got something working.\r\n\r\nWhat works?\r\n\r\n- `eavt` and `aevt` indexes\r\n- `.TransactDatoms`, without *any* checks whatsoever\r\n    - no new entity ids\r\n    - no value type checking (i.e. you can store whatever you want)\r\n    - no attribute checking (i.e. no schema)\r\n    - it's just for straight-up imports from a datomic database\r\n\r\nWhat's missing?  (For certain values of \"missing\".  A more precise question would be \"What's missing before we can use this to store data at all?\")\r\n\r\n- entity id creation (and temporary ids)\r\n- on disk storage\r\n- avet and vaet indexes (need schema support, so maybe postpone until later as well)\r\n- ...\r\n\r\n    everything else, but out of scope until we actually stored some data on disk and used it for a (tiny) bit.",
		"created": "2015-04-16T22:06:48.065160772+02:00"
	},
	{
		"id": "4043e3bbfe84d0e9ed670afead37bbb2",
		"title": "Comparing Datoms",
		"content": "- multiple comparators (one per index type)\r\n- `.Value()` is most complex (no `\u003c` for `interface{}` values, or even `[]byte`)\r\n\r\na bit of (slightly) pseudo code:\r\n\r\n```go\r\nfunc CompareEavt(a, b Datom) int {\r\n    if a.entity \u003c b.entity {\r\n        return -1\r\n    } else if a.attribute \u003c b.attribute {\r\n        return -1\r\n    } else if a.value.Compare(b.value) \u003c 0 { // pseudo\r\n        return -1\r\n    } else if a.transaction \u003c b.transaction {\r\n        return -1\r\n    } else if a.entity == b.entity\r\n        \u0026\u0026 a.attribute == b.attribute\r\n        \u0026\u0026 a.value.Compare(b.value) == 0     // pseudo\r\n        \u0026\u0026 a.transaction == b.transaction {\r\n        return 0\r\n    } else {\r\n        return 1\r\n    }\r\n}\r\n```\r\n\r\nsome problems with that:\r\n\r\n- `.value` is an `interface{}` currently, not a `Comparable`\r\n    - not sure if we should wrap it and if we do so, how\r\n        - a `Value` type, `Comparable` with a type switch\r\n        - individual wrappers, all implementing `Comparable`\r\n        - in any case, it must still be possible to compare values of *different* types (at least those supported by datomic)\r\n- it seems quite inefficient (i.e. no fast path for `==` or `\u003e`)",
		"created": "2015-04-16T15:44:58.808596849+02:00"
	},
	{
		"id": "e9b6a74a383307b45d6b92bb98da15a9",
		"title": "An non-segmented in-memory variant",
		"content": "To get started, able to experiment with an API and actually store some data with `mu`.\r\n\r\n- `mu`\r\n    - `Datoms(db, ...)`, `SeekDatoms(db, ...)`\r\n        - decides which index to use, calls `.Datoms` or `.SeekDatoms` on it\r\n    - `Db(conn)`\r\n    - `Transact(conn, txData)`\r\n- `Index`\r\n    - `Datoms(d Datom)`\r\n    - `SeekDatoms(d Datom)`\r\n- `Database`\r\n    - `Eavt()`, `Aevt()`, `Avet()`, `Vaet()`\r\n- `Connection`\r\n    - `Db()`\r\n    - `Transact(txData)` (should it return a map/info thing as well, or just an error?)",
		"created": "2015-04-15T14:53:06.061671079+02:00"
	},
	{
		"id": "538111cee1426b9fd7fedc89115d4604",
		"title": "Navigating indexes",
		"content": "Now that `index.Datoms` returns an `Iterator`, we can implement more efficient access to the index.  In fact, we could (and maybe should) implement `index.SeekDatoms` as well, and then build `.Datoms` on top of it.  (`.SeekDatoms` starts at an \"approximate\" match and only stops at the end of the index, `.Datoms` matches exactly.)\r\n\r\nGiven leading components, we need to find the index into the segment where the first relevant datom resides.  If there is no matching datom, the iterator will immediately return `nil`.\r\n\r\nI think this is a kind of bounds checking.  The default bounds will be `0, MaxInt` (or some equivalent, given that we have three indexes), but specifying leading components will narrow down those bounds.\r\n\r\nLet's say we have one leading component, `42`, and we're searching the `.Eavt` index.  Let's also assume that our root has two segments, with the following `tdata.entities`: `[0, 30]`.  By comparing our leading entity component, we know that we don't need to search the first segment.  (It may really be easier to implement `.SeekDatoms` first, as we don't have to check when to stop...)\r\n\r\nThen, given the dir node we just found, check it's `tdata.entities` and find the first segment that \"matches\".  Matching means `tdata.entities[i] \u003e= 42`, assuming we have started searching at the start.  The same is to be done for the `segment.entities`.\r\n\r\nWe probably could do this more efficiently by using binary search for the first entity.",
		"created": "2015-03-20T09:19:23.119332331+01:00"
	},
	{
		"id": "afbc191f18392a3e7243cb6b4c8fd0a8",
		"title": "Reading up on Red-Black trees",
		"content": "- Chris Okasaki's [Red-Black Trees in a Functional Setting](http://www.usma.edu/eecs/_layouts/wpFacultyBios/DisplayBio.aspx?ID=ada3b9ec-2e1f-40ef-8a4b-aa32586cfcb5\u0026List=f5e1151c-c15d-420c-b0fa-7919e148c1b7#jfp99)\r\n    - possibly Matt Might's [post on deletion](http://matt.might.net/articles/red-black-delete/) in addition, if only for the images and additional understanding.  (we won't ever delete, we'll just add new segments.)\r\n- [clojure.lang.PersistentTreeMap](https://github.com/clojure/clojure/blob/master/src/jvm/clojure/lang/PersistentTreeMap.java)\r\n    - Rich Hickey said in [Writing Datomic in Clojure](http://www.infoq.com/presentations/Datomic) that the indexes are *not* the red-black trees, but have a far wider branching factor.  however, it can't be bad to read a bit more and maybe implement them just for fun?\r\n    - maybe `clojure.lang.PersistentVector` would be helpful?",
		"created": "2015-03-19T20:46:27.312948344+01:00"
	},
	{
		"id": "f8e230ce77dbbe2a5ef935755ebf2c67",
		"title": "Tomorrow",
		"content": "- ~~change `index.Datoms` so that it returns an `Iterator`~~\r\n    - ~~should be usable similar to the current `range` in for loops~~ (kind of, channels would have been best, but various microbenchmarks say they're too slow)\r\n- think about more efficient access to the index, by specifying leading \"components\" to `.Datoms` or a variant of it\r\n    - it's a bit tricky because the types likely going to be just `interface{}`, otherwise we'd need one function per arity and also specific to the index type/order\r\n- thinking about `.Datoms` also implies thinking about a `Comparable` interface, because the index access somewhat requires that\r\n    - we didn't need to worry about it so far because the order was implicit, and we did not really use it\r\n    - with more efficient access we need to know what order the components of the index are in\r\n    - it might involve different index types, but hopefully a `Comparable` interface will be enough\r\n\r\na few more ideas:\r\n\r\n- `entity.Get` should get smarter\r\n    - with caching\r\n    - respecting cardinality\r\n    - resolve attribute ids back to the keywords\r\n    - (and in the stars: the datomic docs say it supports *recursive* access, i.e. for `:db.type/ref` attributes, so that call should return *another* Entity.  saying it like that makes it seem almost... easy?  just return (and cache) a new Entity with the given id and the db in the entity.)\r\n    - `entity.touch` would be nice\r\n        - only makes sense with either pretty printing or `.Keys`\r\n- think about getting back some type info (it's all there, `:db/valueType` tells us what we get back, now we just need to think of a way to use that information.)\r\n- if there is some head-space, at some point we need to think about adding information, which is likely the most interesting part\r\n    - learning more about indexes and their ordering first (by way of improving `.Datoms`) would be helpful, though.\r\n    - one way towards this would be something in-memory (which is only natural, but doing less at each step makes things easier/possible)\r\n- `Datom` could be just a pointer to a segment and an index\r\n    - not sure whether this would be of any use, but it *might* help\r\n    - in any case, we definitely don't want to construct all the datoms we touch in `.Datoms`",
		"created": "2015-03-18T19:37:06.425978072+01:00"
	},
	{
		"id": "194f5f232b0a79869769e420cbdae2ac",
		"title": "A tiny lesson in software design",
		"content": "Phew.  After quite a bit of struggling with refactoring the mess I've made yesterday.  (A working mess, yes, but one where every part of the code could touch every *other* part.)\r\n\r\nThe most difficult part was understanding which parts depend on which, and deciding how to structure the code.  In the end I removed *all* of the previous code and started from the top-level calls to `.Connect` and `conn.Db`.  From there, I filled everything out gradually, being very generous with `nil`s, empty interfaces and structs.  And after an hour (or several) it was all working again.\r\n\r\nNow we have all the capabilities we had yesterday, but nicely separated.  (One could even argue that the code has *too much* separation right now, but as I expect it to grow I wanted to explicitely specify which subsystems depend on which.)\r\n\r\nThe lesson?  Don't make a big mess, start with interfaces/the dream and take a walk when you don't understand your own code.  In the end drawing a picture of the dependencies helped me quite a bit, after which I started with the top-down approach described above.\r\n\r\nOnwards!",
		"created": "2015-03-18T19:27:43.905166637+01:00"
	},
	{
		"id": "f2d9c94af966530ed1ac879569f95e43",
		"title": "Sketching the API for 0.1.0",
		"content": "```go\r\n// package mu\r\n\r\nfunc Connect(u *url.URL) (Connection, error) {}\r\nfunc Db(c Connection) Database {}\r\n\r\nfunc (db Database) Eavt() Index {}\r\nfunc (db Database) Aevt() Index {}\r\n\r\nfunc (i Index) Datoms(components... interface{}) Iterator {}\r\nfunc (i Index) Datoms(components... interface{}) Iterator {}\r\n\r\nfunc (it Iterator) Current() Datom {}\r\nfunc (it Iterator) Next() bool {}\r\n```",
		"created": "2015-03-17T17:00:25.789669594+01:00"
	},
	{
		"id": "f1b4267bdccd97224bc71c8b72f559cf",
		"title": "Thinking about queries...",
		"content": "- iterations through the datoms should not do allocations, so `index.Datoms()` should return an `Iterator`, or something similar\r\n- what should our equivalent to `datomic.api/datoms` look like? especially, the `components' part, which specify \"leading\" parts to narrow the result?\r\n\r\n    ```go\r\n    // direct translation\r\n    func (db Db) Datoms(index Keyword, components ...interface{})\r\n\r\n    // per-index\r\n    func (i Index) Datoms(components ...interface{})\r\n    ```\r\n- the segment/thing cache should be global, as an intermediate layer between storage and the rest of the system\r\n\r\n    ```go\r\n    type Store interface {\r\n        Get(id string) []byte    // or maybe `*fressian.Reader`?\r\n    }\r\n\r\n    // Cache would be just another store?\r\n    //   not really, it would just support `.Get`\r\n    ```\r\n\r\n    - when do we access the cache?  when querying the index, i.e. when using `.Datoms`.  it should be invisble to the user, though.",
		"created": "2015-03-17T16:15:01.403505716+01:00"
	},
	{
		"id": "01047148e2db0a90c18a1df6c5527b17",
		"title": "So",
		"content": "This morning has been a bit... surprising, because *we can read dbs now!*\r\n\r\nBut, what next?  Some ideas:\r\n\r\n- a simple http server to get the data from the indexes\r\n    - not so useful though, because attributes are not yet resolved \"back\"\r\n    - so maybe implement attribute resolution?  (would be an eavt lookup: find attribute 10 (`:db/ident`) of `\u003cattr-id\u003e`)\r\n- segment caching (in-memory, to prevent reading them with each `.allDatoms` call)\r\n    - would improve design of `.allDatoms`, because it would use the cache, removing the need for the `baseDir` argument)\r\n- pluggable backends (preparing for `sqlite://`, but starting with `backup://`.  hopefully has some good effects on the design as well)\r\n- think a bit about queries, how to execute them on raw indexes.  (e.g. `:db/ident` resolution above, maybe something à la `datomic.api/entity`?)\r\n- experiment with the log tail (seems to be `[{:id \"\u003cuuid\u003e\", data: \u003cdatoms\u003e}]`)\r\n- try adding new data to an index\r\n    - would need a type for UUIDs (at least a while later, in general anytime we want generate new segments)\r\n    - is there a different \"in-memory\" index type?\r\n    - the index is persistent, right?\r\n    - can we batch-add data?  (think of data from one transaction, we don't want the values in between, we want the index after the *complete* transaction)",
		"created": "2015-03-17T13:15:03.418087399+01:00"
	},
	{
		"id": "afb7dda1ba295acdcb2857e2ad6f7bde",
		"title": "Finding things in a Datomic index",
		"content": "say we have an `eavt` index, what happens (or needs to happen) when we want to find something in it?  first, even though we want to find *something*, when talking about the index we're always talking about finding *segments* that contain whatever we want to find.\r\n\r\nmhh... maybe we don't want to *find* things first, but to read all the datoms in order?\r\n\r\nthat should be easy:\r\n\r\n1. for each dir node referenced in the root node (in order):\r\n    1. for each segment, construct all the datoms\r\n    2. move on to next dir node\r\n2. done?\r\n\r\nwhat about finding specific datoms, let's say those about entity `42`?\r\n\r\n1. look in the `tdata` of the root node, find the offset of the `entities` entry whose value is greater than 42\r\n    - what if the data about one entity spans more than one segment? (is that possible, that would mean several thousand of datoms about one entity, but maybe it is...)\r\n    - in the following, assume only one such segment exists\r\n    - could be relatively easy, just go through multiple segments.  finding the right segment is not so easy, though, we have to find the greater entry as before, but we also have to look whether it's possible to find the id several segments before\r\n        - example: `tdata.entities` contains `[0 34 34 42 42 50]`.  i think that datoms about entity `42` could exist in segments 2, 3 and 4 (counting starts at zero).\r\n2. ",
		"created": "2015-03-16T21:12:00.406839601+01:00"
	},
	{
		"id": "c99bc2ae3f06c6866ccb8cec9decf515",
		"title": "mu",
		"content": "Now a separate project, because fressian *is* a separate project at this point.  However, maybe we want to make fressian (or `encoding/fressian`) a subproject of this thing?  I'm not decided about that, but I think that would make some sense, given that I mostly want fressian to read and write datomic-y things.\r\n\r\nSo, what is `mu`?  The logical continuation of the stuff I played with in fressian, and also the continuation of what I did with `muq`.  Eventually I hope to store data from things like `gol` in `mu`.\r\n\r\nAgain, what *is* `mu`?  Or rather, what does it want to be?  It wants to be an embeddable Datomic-inspired database.  It should be somewhat like sqlite (lightweight, single file, usable anywhere), but have the power of Datomic (history, query language, ~feeling~).\r\n\r\n`mu` is alien-space technology in your \\*nix.",
		"created": "2015-03-16T20:59:26.173574182+01:00"
	},
	{
		"id": "1da5347cb0585f4cdf4d4809543753f9",
		"title": "Datomic backup structure",
		"content": "(basically just indexes written to disk...)\r\n\r\n- `roots/\u003ctid\u003e` contains the latest root of the index (multiple = multiple backups?)\r\n    - initial root is `roots/1000`\r\n\r\n    example of a root:\r\n\r\n    ```clojure\r\n    {\r\n      :db/id \"initial-ad6d5575-03e3-438b-a4ed-0bca6a4968a2\"\r\n      :backup/version 3\r\n      :index/version 2\r\n      ; contains the various indexes\r\n      :index/root-id \"5507037f-2f72-4c96-a1f0-96bdf8f61acf\"\r\n      :log/version 3\r\n      :log/root-id \"5507037f-6509-4968-b382-682cfe1141a1\"\r\n      ; fressian encoded log (i.e. not yet indexed data, 0xee = fressian open list)\r\n      :log/tail #bytes [0xee]\r\n    }\r\n    ```\r\n- `values/\u003c2-char suffix\u003e/\u003cuuid\u003e` contain the various parts of the tree\r\n\r\n`:index/root-id` has references to the roots of the current indexes:\r\n\r\n```clojure\r\n{\r\n  :buildRevision 5130\r\n  :rev 0\r\n  :version 2\r\n  :nextT 1000 ; ah, so not current tx, but obviously the next tx id\r\n\r\n  :eavt-main \"5507037f-cbee-42ce-8339-c2a0edae286b\"\r\n  :eavt-mid nil\r\n  :eavt-hist nil\r\n\r\n  :aevt-main \"5507037f-60c4-429c-bffc-60be52ad6ec5\"\r\n  :aevt-mid nil\r\n  :aevt-hist nil\r\n\r\n  :avet-main \"5507037f-c011-435e-8be6-438ab2a6e0d8\"\r\n  :avet-mid nil\r\n  :avet-hist nil\r\n\r\n  :raet-main \"5507037f-0853-47bd-9ebc-2006a1e3d0f8\"\r\n  :raet-mid nil\r\n  :raet-hist nil\r\n}\r\n```\r\n\r\n- `:\u003cindex\u003e-main` has the current set of data, `-mid` and `-hist` supposedly stepped older data\r\n\r\nlet's look at `:eavt-main`.  it is a reference to the EAVT index, more specifically, to the root node of that index.\r\n\r\n```clojure\r\n#index-root-node [\r\n  #index-tdata [\r\n    [:db.part/db]     ; values\r\n    #ints [0]         ; entities\r\n    #ints [10]        ; attributes\r\n    #ints [0]         ; transactions (offset from `3 * (1 \u003c\u003c 42)`)\r\n    #booleans [true]  ; added\r\n  ]\r\n  [\"5507037f-9444-4931-8109-e34ee5963e7e\"] ; dir nodes\r\n]\r\n```\r\n\r\ni *think* that `index-tdata` is used to find the dir-node to move down to, but i'm not sure.  (need to find an example with multiple dir nodes!)  however, it is very likely that this is so, and that `index-tdata` contains the minimum values for the various parts of the datoms, i.e. the lowest value is `:db.part/db` and the lowest entity id is `0`.\r\n\r\nbecause there is so few data in the db initially, the dir node referenced above looks almost the same:\r\n\r\n```clojure\r\n#index-dir-node [\r\n  #index-tdata [   ; as above, likely used to find the segment\r\n    [:db.part/db]\r\n    #ints [0]\r\n    #ints [10]\r\n    #ints [0]\r\n    #booleans [true]\r\n  ]\r\n  [\"5507037f-b42b-4eb2-8e1d-bc1af83ebf3b\"] ; segments\r\n  ; no idea what these two are for\r\n  #ints [0]\r\n  #ints [211]\r\n]\r\n```\r\n\r\nand finally, let's have a look at the segment:\r\n\r\n```clojure\r\n#index-tdata [\r\n  [\r\n    :db.part/db\r\n    0\r\n    3\r\n    4\r\n    20\r\n    21\r\n    22\r\n    23\r\n    24\r\n    25\r\n    26\r\n    27\r\n    56\r\n    57\r\n    58\r\n    59\r\n    60\r\n    61\r\n    10\r\n    11\r\n    12\r\n    13\r\n    14\r\n    15\r\n    16\r\n    17\r\n    18\r\n    19\r\n    39\r\n    40\r\n    41\r\n    42\r\n    43\r\n    44\r\n    45\r\n    46\r\n    47\r\n    50\r\n    51\r\n    52\r\n    62\r\n    54\r\n    55\r\n    \"Name of the system partition. The system partition includes the core of datomic, as well as user schemas: type definitions, attribute definitions, partition definitions, and data function definitions.\"\r\n    :db/add\r\n    \"Primitive assertion. All transactions eventually reduce to a collection of primitive assertions and retractions of facts, e.g. [:db/add fred :age 42].\"\r\n    :db/retract\r\n    \"Primitive retraction. All transactions eventually reduce to a collection of assertions and retractions of facts, e.g. [:db/retract fred :age 42].\"\r\n    :db.part/tx\r\n    \"Partition used to store data about transactions. Transaction data always includes a :db/txInstant which is the transaction's timestamp, and can be extended to store other information at transaction granularity.\"\r\n    :db.part/user\r\n    \"Name of the user partition. The user partition is analogous to the default namespace in a programming language, and should be used as a temporary home for data during interactive development.\"\r\n    :db/ident\r\n    21\r\n    35\r\n    38\r\n    \"Attribute used to uniquely name an entity.\"\r\n    :db.install/partition\r\n    20\r\n    36\r\n    \"System attribute with type :db.type/ref. Asserting this attribute on :db.part/db with value v will install v as a partition.\"\r\n    :db.install/valueType\r\n    20\r\n    36\r\n    \"System attribute with type :db.type/ref. Asserting this attribute on :db.part/db with value v will install v as a value type.\"\r\n    :db.install/attribute\r\n    20\r\n    36\r\n    \"System attribute with type :db.type/ref. Asserting this attribute on :db.part/db with value v will install v as an attribute.\"\r\n    :db.install/function\r\n    20\r\n    36\r\n    \"System attribute with type :db.type/ref. Asserting this attribute on :db.part/db with value v will install v as a data function.\"\r\n    :db/excise\r\n    20\r\n    35\r\n    :db.excise/attrs\r\n    20\r\n    36\r\n    :db.excise/beforeT\r\n    22\r\n    35\r\n    :db.excise/before\r\n    25\r\n    35\r\n    :db.alter/attribute\r\n    20\r\n    36\r\n    \"System attribute with type :db.type/ref. Asserting this attribute on :db.part/db with value v will alter the definition of existing attribute v.\"\r\n    :db.type/ref\r\n    :ref\r\n    \"Value type for references. All references from one entity to another are through attributes with this value type.\"\r\n    :db.type/keyword\r\n    :key\r\n    \"Value type for keywords. Keywords are used as names, and are interned for efficiency. Keywords map to the native interned-name type in languages that support them.\"\r\n    :db.type/long\r\n    :int\r\n    \"Fixed integer value type. Same semantics as a Java long: 64 bits wide, two's complement binary representation.\"\r\n    :db.type/string\r\n    :string\r\n    \"Value type for strings.\"\r\n    :db.type/boolean\r\n    :bool\r\n    \"Boolean value type.\"\r\n    :db.type/instant\r\n    :inst\r\n    \"Value type for instants in time. Stored internally as a number of milliseconds since midnight, January 1, 1970 UTC. Representation type will vary depending on the language you are using.\"\r\n    :db.type/fn\r\n    :datomic/fn\r\n    \"Value type for database functions. See Javadoc for Peer.function.\"\r\n    :db.type/bytes\r\n    :bytes\r\n    \"Value type for small binaries. Maps to byte array on the JVM.\"\r\n    :db.cardinality/one\r\n    \"One of two legal values for the :db/cardinality attribute. Specify :db.cardinality/one for single-valued attributes, and :db.cardinality/many for many-valued attributes.\"\r\n    :db.cardinality/many\r\n    \"One of two legal values for the :db/cardinality attribute. Specify :db.cardinality/one for single-valued attributes, and :db.cardinality/many for many-valued attributes.\"\r\n    :db.unique/value\r\n    \"Specifies that an attribute's value is unique. Attempts to create a new entity with a colliding value for a :db.unique/value will fail.\"\r\n    :db.unique/identity\r\n    \"Specifies that an attribute's value is unique. Attempts to create a new entity with a colliding value for a :db.unique/value will become upserts.\"\r\n    :fressian/tag\r\n    21\r\n    35\r\n    true\r\n    \"Keyword-valued attribute of a value type that specifies the underlying fressian type used for serialization.\"\r\n    :db/valueType\r\n    20\r\n    35\r\n    \"Property of an attribute that specifies the attribute's value type. Built-in value types include, :db.type/keyword, :db.type/string, :db.type/ref, :db.type/instant, :db.type/long, :db.type/bigdec, :db.type/boolean, :db.type/float, :db.type/uuid, :db.type/double, :db.type/bigint,  :db.type/uri.\"\r\n    :db/cardinality\r\n    20\r\n    35\r\n    \"Property of an attribute. Two possible values: :db.cardinality/one for single-valued attributes, and :db.cardinality/many for many-valued attributes. Defaults to :db.cardinality/one.\"\r\n    :db/unique\r\n    20\r\n    35\r\n    \"Property of an attribute. If value is :db.unique/value, then attribute value is unique to each entity. Attempts to insert a duplicate value for a temporary entity id will fail. If value is :db.unique/identity, then attribute value is unique, and upsert is enabled. Attempting to insert a duplicate value for a temporary entity id will cause all attributes associated with that temporary id to be merged with the entity already in the database. Defaults to nil.\"\r\n    :db/isComponent\r\n    24\r\n    35\r\n    \"Property of attribute whose vtype is :db.type/ref. If true, then the attribute is a component of the entity referencing it. When you query for an entire entity, components are fetched automatically. Defaults to nil.\"\r\n    :db/index\r\n    24\r\n    35\r\n    \"Property of an attribute. If true, create an AVET index for the attribute. Defaults to false.\"\r\n    :db/noHistory\r\n    24\r\n    35\r\n    \"Property of an attribute. If true, past values of the attribute are not retained after indexing. Defaults to false.\"\r\n    :db/lang\r\n    20\r\n    35\r\n    \"Attribute of a data function. Value is a keyword naming the implementation language of the function. Legal values are :db.lang/java and :db.lang/clojure\"\r\n    :db/code\r\n    23\r\n    35\r\n    true\r\n    \"String-valued attribute of a data function that contains the function's source code.\"\r\n    :db.lang/clojure\r\n    \"Value of :db/lang attribute, specifying that a data function is implemented in Clojure.\"\r\n    :db.lang/java\r\n    \"Value of :db/lang attribute, specifying that a data function is implemented in Java.\"\r\n    :db/txInstant\r\n    25\r\n    35\r\n    true\r\n    \"Attribute whose value is a :db.type/instant. A :db/txInstant is recorded automatically with every transaction.\"\r\n    :db/fulltext\r\n    24\r\n    35\r\n    \"Property of an attribute. If true, create a fulltext search index for the attribute. Defaults to false.\"\r\n    :db/fn\r\n    26\r\n    35\r\n    \"A function-valued attribute for direct use by transactions and queries.\"\r\n    :db.bootstrap/part\r\n    :db.fn/retractEntity\r\n    48\r\n    \"(clojure.core/fn [db e] (datomic.builtins/build-retract-args db e))\"\r\n    \"Retract all facts about an entity, including references from other entities and component attributes recursively.\"\r\n    :db.fn/cas\r\n    48\r\n    \"(clojure.core/fn [db e a ov nv] (datomic.builtins/compare-and-swap db e a ov nv))\"\r\n    \"Compare and swap the value of an entity's attribute.\"\r\n    :db.type/uuid\r\n    :uuid\r\n    \"Value type for UUIDs. Maps to java.util.UUID on the JVM.\"\r\n    :db.type/double\r\n    :double\r\n    \"Floating point value type. Same semantics as a Java double: double-precision 64-bit IEEE 754 floating point.\"\r\n    :db.type/float\r\n    :float\r\n    \"Floating point value type. Same semantics as a Java float: single-precision 32-bit IEEE 754 floating point.\"\r\n    :db.type/uri\r\n    :uri\r\n    \"Value type for URIs. Maps to java.net.URI on the JVM.\"\r\n    :db.type/bigint\r\n    :bigint\r\n    \"Value type for arbitrary precision integers. Maps to java.math.BigInteger on the JVM.\"\r\n    :db.type/bigdec\r\n    :bigdec\r\n    \"Value type for arbitrary precision floating point numbers. Maps to java.math.BigDecimal on the JVM.\"\r\n    :db/doc\r\n    23\r\n    35\r\n    true\r\n    \"Documentation string for an entity.\"\r\n    #inst \"1970-01-01T01:00:00+01:00\"\r\n    #inst \"1970-01-01T01:00:00+01:00\"\r\n    #inst \"1970-01-01T01:00:00+01:00\"\r\n  ]\r\n  #ints [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 10, 10, 10, 10, 10, 11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 27, 27, 27, 35, 35, 36, 36, 37, 37, 38, 38, 39, 39, 39, 39, 39, 40, 40, 40, 40, 41, 41, 41, 41, 42, 42, 42, 42, 43, 43, 43, 43, 44, 44, 44, 44, 45, 45, 45, 45, 46, 46, 46, 46, 47, 47, 47, 47, 47, 48, 48, 49, 49, 50, 50, 50, 50, 50, 51, 51, 51, 51, 52, 52, 52, 52, 53, 54, 54, 54, 54, 55, 55, 55, 55, 56, 56, 56, 57, 57, 57, 58, 58, 58, 59, 59, 59, 60, 60, 60, 61, 61, 61, 62, 62, 62, 62, 62, 13194139533366, 13194139533368, 13194139533375]\r\n  #ints [10, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 62, 10, 62, 10, 62, 10, 62, 10, 62, 10, 40, 41, 42, 62, 10, 40, 41, 62, 10, 40, 41, 62, 10, 40, 41, 62, 10, 40, 41, 62, 10, 40, 41, 10, 40, 41, 10, 40, 41, 10, 40, 41, 10, 40, 41, 62, 10, 39, 62, 10, 39, 62, 10, 39, 62, 10, 39, 62, 10, 39, 62, 10, 39, 62, 10, 39, 62, 10, 39, 62, 10, 62, 10, 62, 10, 62, 10, 62, 10, 40, 41, 44, 62, 10, 40, 41, 62, 10, 40, 41, 62, 10, 40, 41, 62, 10, 40, 41, 62, 10, 40, 41, 62, 10, 40, 41, 62, 10, 40, 41, 62, 10, 40, 41, 51, 62, 10, 62, 10, 62, 10, 40, 41, 44, 62, 10, 40, 41, 62, 10, 40, 41, 62, 10, 10, 46, 47, 62, 10, 46, 47, 62, 10, 39, 62, 10, 39, 62, 10, 39, 62, 10, 39, 62, 10, 39, 62, 10, 39, 62, 10, 40, 41, 51, 62, 50, 50, 50]\r\n  #ints [0, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 56, 56, 56, 56, 56, 56, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 56, 54, 54, 63, 0, 63, 0, 63, 0, 63, 0, 63, 0, 54, 54, 54, 63, 0, 54, 54, 63, 0, 54, 54, 63, 0, 54, 54, 63, 0, 54, 54, 63, 0, 54, 54, 0, 54, 54, 0, 54, 54, 0, 54, 54, 0, 54, 54, 63, 0, 54, 63, 0, 54, 63, 0, 54, 63, 0, 54, 63, 0, 54, 63, 0, 54, 63, 0, 54, 63, 0, 54, 63, 0, 63, 0, 63, 0, 63, 0, 63, 0, 54, 54, 54, 63, 0, 54, 54, 63, 0, 54, 54, 63, 0, 54, 54, 63, 0, 54, 54, 63, 0, 54, 54, 63, 0, 54, 54, 63, 0, 54, 54, 63, 0, 54, 54, 54, 63, 0, 63, 0, 63, 0, 54, 54, 54, 63, 0, 54, 54, 63, 0, 54, 54, 63, 0, 54, 54, 54, 63, 54, 54, 54, 63, 56, 56, 63, 56, 56, 63, 56, 56, 63, 56, 56, 63, 56, 56, 63, 56, 56, 63, 56, 56, 56, 56, 63, 54, 56, 63]\r\n  #booleans [true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true]\r\n]\r\n```\r\n\r\nthis is fairly interesting, i would have thought that datoms are stored separately.  it's probably for efficiency (typed arrays), but maybe there are more reasons.\r\n\r\nthe first datom would thus be the one constructed from the first entry of each of the fields: `#datom [0 10 0 13194139533312 true]`  why the big tx id?  because they're stored with an implicit offset from `3 * (1 \u003c\u003c 42)`.\r\n\r\nwhat does this mean?  considering that the format is `[e a v tx added]` and that attributes are mapped to integers internally (the mapping is also defined in the above data), this means that the `:db.part/db` of entity `0` is `0` itself.  this is just the information that `:db.part/db` is stored in the `:db.part/db` partition.  it is self-refential because in datomic *everything* is stored in the db, including the schema and internal attributes.  this is how it all starts.  :)\r\n\r\nso, what to do with this newly gained knowledge?  of course, we'd like not just to read it in, but access the datoms (à la `datomic.api/datoms`) from an index programmatically.  for that we need to teach fressian how to use custom handlers.\r\n\r\nafter that, we definitely need data with multiple dir nodes, or at least dir nodes that reference multiple segments.  i think we could trick datomic into making the segments smaller, but maybe we just need to just a simple large test dataset.\r\n\r\nmaybe we can just have it counting upwards?  i.e. `[e1 :num 1], [e2 :num 2], [e3 :num 3], ...` and then test how long it takes until we get a new segment.",
		"created": "2015-03-16T18:49:29.874026398+01:00"
	},
	{
		"id": "47a755f05315d612f6bb2a2d9374d77e",
		"title": "Exploring Datomic's indexes",
		"content": "- they're sorted sets of datoms\r\n- comparators are pluggable\r\n- similar to the red-black trees in clojure (also for sorted sets?), but with a very high branching factor\r\n- three levels: root node, directory nodes and segments containing the datoms\r\n- fast merging of on-disk indexes and new facts from the log/via pushes from the transactor\r\n\r\nafter exploring a bit, some theories:\r\n\r\n- datoms are not stored directly, but as arrays of fields, i.e. one long array of values, one of entity ids, etc\r\n- dir nodes also have arrays of values, likely denoting \"starting\"/smallest values of the respective fields\r\n- transaction ids are not stored directly, but as an offset from `3 * (1 \u003c\u003c 42) == 13194139533312` (which is the first transaction that adds the core attributes)\r\n    - i think each additional partition is one more multiple of `1 \u003c\u003c 42` from that, for example the entity ids in `:db.part/user` start from `4 * (1 \u003c\u003c 42) == 17592186044416`\r\n    - or rather:\r\n        - ids for `:db.part/db` start at 0 (the id of `:db.part/db` itself)\r\n        - ids for `:db.part/tx` start at `3 * (1 \u003c\u003c 42)` (the tx id of the initial transaction)\r\n            - on disk, those ids are stored as an offset from `3 * (1 \u003c\u003c 42)`, presumably to save space\r\n        - ids for `:db.part/user` start at `4 * (1 \u003c\u003c 42)`\r\n            - possibly also stored differently on disk?\r\n\r\nwhat would i have to do to be able to read (and process) the backups in Go?\r\n\r\n- custom handlers, to transform `#index-root-node`, `#index-dir-node` and `#index-tdata` into a custom data structure while reading it in\r\n- probably a UUID data type (but not necessarily, but I'd definitely need it later on)\r\n- a slightly bigger test db\r\n    - maybe i can just use the seattle schema?\r\n-  that's it?",
		"created": "2015-03-16T13:46:35.634043805+01:00"
	},
	{
		"id": "7f9d3d6ac6d15b9424c3d9bc4fa0de81",
		"title": "datomic notes",
		"content": "- \"Writing Datomic in Clojure\" [video/slides](http://www.infoq.com/presentations/Datomic)\r\n    - has quite a few internal details, watch it if you want to learn more\r\n    - queries are answered from a merge of in-memory and on-disk data\r\n        - makes persistent on-disk index easier (\"less garbage collection\")\r\n        - everything is still made durable immediately, but not necessarily in the index\r\n            - it's (at least) in the log\r\n\r\nthe various resources about datomic often mention somewhat cryptic (to me) terms, let's start collecting them, maybe written down they will become more meaningful:\r\n\r\n- covering indices (the index has the data, e.g. 3 indices -\u003e data is stored 3 times, the most important benefit is probably performance)\r\n- \"wide branching factor\" (probably *very* wide, i.e. hundreds, maybe even thousands of child nodes)\r\n- \"find any segment with 1-2 storage lookups\" (related to the branching factor, but probably also the result of *other things*)\r\n- the live index is a \"merge of on-disk and in-memory data\"\r\n\r\nterms:\r\n\r\n- datom: entity, attribute, value, transaction, (added?)\r\n    - attributes (also values?) are (sometimes?) mapped to numbers on disk/in the index, likely for (storage) efficiency reasons\r\n- index: ?\r\n    - eavt, aevt, ...\r\n    - from the \"unnofficial guide\":\r\n\r\n        \u003e B-tree-like structures: sorted, immutable, persistent, 1,000+ branching factor, custom sort order, fast lookup and range scans, able to be efficiently merged (details unknown). Index trees are shallow, no more than three level deep: root node, directories and segments as leafs.\r\n        - what are \"directories\"?\r\n    - three parts: history (outdated/retracted datoms, durable), current (latest assertions only (gc because of this?), durable) and in-memory (merged, accumulates novelty)\r\n        - new peers build in-memory index from the current index and the transactions in the log from that point onwards\r\n    - \"pluggable comparators\"\r\n- partition: helps group relevant data closely together in storage/indices\r\n    - \"big pre-allocated entity id ranges\" (2\u003csup\u003e42\u003c/sup\u003e)\r\n- entity id\r\n    - somewhat time based (high bits?)\r\n        - semi-sequential: \"uuid whose most significant 32 bits are currentTimeMillies rounded to seconds\"\r\n    - chosen/generated so that \"related\" data is stored together\r\n        - e.g. same transaction -\u003e closer together, same partition -\u003e closer together\r\n        - \"data from the same transaction is stored togeher\"\r\n- segment: some amount (~50kb, 1000-20000, [source](http://docs.datomic.com/capacity.html#sec-6)) of datoms\r\n    - fressian encoded, gzipped, [heyLu/fressian](https://github.com/heyLu/fressian) can read those segments\r\n    - they are [garbage collected](http://docs.datomic.com/capacity.html#sec-7) when no longer referenced\r\n    - **immutable**, i.e. the *entire* database is an immutable value\r\n\r\nquestions:\r\n\r\n- how are segments segmented?\r\n    - some ideas: number of datoms (1000-10000?)\r\n- how is an index/tree built from segments?\r\n- maybe i should implement some other persistent data structures before trying to figure out datomic?\r\n\r\nnotes:\r\n\r\n- i don't need the \"peer\" part, i'm primarily interested in the persistent db\r\n    - the goal is something like sqlite, but as a persistent db\r\n\r\nresources\r\n\r\n- datomic docs:\r\n    - [indexes](http://docs.datomic.com/indexes.html)\r\n- the BigTable paper influential for merging\r\n- [Unofficial guide to Datomic internals](http://tonsky.me/blog/unofficial-guide-to-datomic-internals/)\r\n- datascript:\r\n    - `btset.cljs` (maybe this is how datomic works internally? or at least very similar?)\r\n    - [A shallow dive into DataScript internals](http://tonsky.me/blog/datascript-internals/)",
		"created": "2015-03-14T21:40:13.62299275+01:00"
	},
	{
		"id": "818ff28b50576536a788bca50366091a",
		"title": "Next steps",
		"content": "- more tests\r\n    - `*_ARRAY`\r\n    - `FLOAT`, `DOUBLE`, `DOUBLE_0`, `DOUBLE_1`\r\n    - for the caches (probably the most tricky)\r\n    - tests should be split up, e.g. `TestReadInt`, `TestReadInt`, `TestReadList`, `TestRead...`\r\n- make it usable\r\n    - `main` should become just `fressian`, maybe in `encoding/fressian`?\r\n    - the pretty-printing part should become a new tool, maybe `fsn pp`?\r\n        - and it would just use the `fressian` package (would require thinking about the public API)\r\n    - document how to use it\r\n- the future\r\n    - writing!\r\n        - maybe write a `gol` backend for fun?\r\n    - extensible handlers, maybe just mirror what `Datomic/fressian` does\r\n    - maybe benchmark it? (not sure against what, would require having some data to use and a benchmark suite for `Datomic/fressian`)\r\n- the far future\r\n    - i also want an `edn` reader (and writer, just for fun)\r\n    - coincidentally, datomic queries are also `edn` data...\r\n    - maybe rename this `clog`? (negative connotations, though.) maybe `clogs`? (\"Holzpantoffel\", not exactly fancy, but kind of cute and indicates that this has multiple things. (`fressian`, `edn`, ...))\r\n\r\nAt this point, I think that we have the world's second most advanced fressian reader? That's... interesting. :)",
		"created": "2015-03-14T14:46:34.959662666+01:00"
	}
]