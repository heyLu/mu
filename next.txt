.v0.1.0

- published before 10th of july 2015
- a readme, with mostly just comments about having fun with this
    - i.e. it's very much a non-production thing, for fun & tiny projects

.next

- mu api
    - iterators should support .Reverse
    - mu.CreateDatabase(url.URL) (bool, error)
        - requires `store.Create(net.URL) (bool, error)`
        - CreateDatabase + Connect will be the general pattern (i.e. no implicit
            db creation)
    - better schema support in the transactor (mostly validation)
    - (more of a style thing: introduce a common/util package with code that is
       currently repeated in a bunch of places.  can't have everything because
       that easily leads to cycles, though.)
- reading transactions from the outside
    - need an edn parser?  yes.  take a look at clojure's parser again and see
        how long it would take to get something working.  (txs only need vectors,
        maps and basic types, tagged values can be added later.)
- tests for transactions (is it usable for simple things already?)
    - maybe write a backend for `gol`?  (or a simpler note taking thing.)
      (would need id generation, though.)
- support for the `log` in the `file` backend
- a real program using `mu`
    - first step: note taking
    - after that: attaching more data to the notes
- compress db files in the `file` backend by default (disable with `&compress=false`)
    - maybe do this in `fressian`, instead of here?  e.g. `NewWriterWithCompress` or similar?  (`NewGzipWriter` sounds better...)
- transactions
    - don't allow transacting the same values twice (this is actually about `:db/unique`, i think)
- notes
    - add a `server` subcommand (a smallish http server that provides an api and a simple web interface)
- mu cli
    - `init` (initialize a db with the default datoms, possibly do this automatically?)
    - `datoms`, `seek-datoms` (specify index and leading components, get datoms)
        - maybe this should be the default command, like `eavt` is now?
    - `q` (or `query`) (possibly later)
    - `transact` (read tx from edn on stdin, report results)

.log

- first attempts at creating new dbs with log & segments
- better transactions ((mostly) typed interface)
- realization how the merging of in-memory and persisted index works
- a simple note taking example application
- transactions (entity & tx id generation, used in the note taking example)
- simple transactions (no id generation, just cardinality one attributes)
- `file` backend (serializing the db to a file using fressian)
